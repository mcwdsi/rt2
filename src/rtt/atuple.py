from uuid6 import uuid7
from datetime import datetime, timezone
  
from src.ids_codes.Rui import Rui, RuiStatus

class RtTuple:
	def __init__(self, ruit):
		if ruit is None:
			self.ruit = Rui(RuiStatus.assigned)
		else:	
			self.ruit = ruit

	def get_ruit(self):
		return self.ruit 

# Assignment tuple, i.e., assigment of a Rui to some entity in reality
#  We can also reserve a Rui, and this class has the ar parameter to 
#	capture that. Depending on whether 
class Atuple(RtTuple):
	"""Referent Tracking assignment tuple that registers assignment of an RUI to a PoR"""
	def __init__(self, ruip=Rui(RuiStatus.assigned), ruia=None, ruit=None, unique="-SU", ar=RuiStatus.assigned, t=datetime.now(timezone.utc)):
		super().__init__(ruit)

		# If we don't get a value for whether the Rui is assigned or reserved
		#	then we assume that it is assigned
		self.ar = ar

		# If we don't get a Ruip, then we'll create one on the fly
		self.ruip = ruip 
		
		# If we don't get an author Rui for the tuple, then autogenerate one,
		#	unless we don't get a Ruip either, in which case set it to the
		#	autogenerated Ruip. 
		# This means that the default behavior is that if neither Ruia nor Ruip
		#	are provided, we are assuming some entity is assigning a Ruip to 
		#	itself, and thus should be equal
		self.ruia = ruia
		if self.ruia is None:
			print(self.ruip.uuid)
			self.ruia = Rui(self.ruip.status, self.ruip.uuid)

		self.unique = unique
		self.t = t

# This class is the superclass of all Nto* tuples. They all relate some
#	non-repeatable portion of reality to some portion of reality (in 
#	some cases a repeatable PoR, and in others non-repeatable ones) or
#	in the case of NtoC, it is asserting that the N is "annotated by"
#	the "concept" from some concept system.
# We require the NtoXGenericTuple to accomodate NtoLackR
#	All the other Nto* tuples extend NtoXTuple
# 
class NtoXGenericTuple(RtTuple):
	def __init__(self, ruit, ruin, r):
		super().__init__(ruit)
		if ruin is None:
			raise Exception("must provide a value for RUIn")
		if r is None:
			raise Exception("must provide a value for r")
		
		self.ruin = ruin
		self.r = r 

# Except for NtoLackR, Nto* tuples can be asserted as being
#  true or false (i.e., "it is not the case that...")
class NtoXTuple(NtoXGenericTuple):
	def __init__(self, ruit, ruin, r, polarity: bool):
		super().__init__(ruit, ruin, r)
		self.polarity = polarity

	def isPositive(self):
		return self.polarity

	def isNegated(self):
		return not self.polarity


