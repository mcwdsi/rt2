from uuid6 import uuid7
from datetime import datetime, timezone

import sys
  
from ids_codes import Rui

class RtTuple:
	def __init__(self, ruit):
		if ruit is None:
			self.ruit = Rui.Rui('A')
		else:	
			self.ruit = ruit

	def get_ruit(self):
		return self.ruit 

# Assignment tuple, i.e., assigment of a Rui to some entity in reality
#  We can also reserve a Rui, and this class has the ar parameter to 
#	capture that. Depending on whether 
class Atuple(RtTuple):
	"""Referent Tracking assignment tuple that registers assignment of an RUI to a PoR"""
	def __init__(self, ruip=None, ruia=None, ruit=None, unique=None, ar=None, t=None):
		super().__init__(ruit)

		# If we don't get a value for whether the Rui is assigned or reserved
		#	then we assume that it is assigned
		if ar is None:
			self.ar = 'A'
		else:
			self.ar = ar

		# If we don't get a Ruip, then we'll create one on the fly
		if ruip is None: 
			self.ruip = Rui.Rui(self.ar)
		else:
			self.ruip = ruip 
		
		# If we don't get an author Rui for the tuple, then autogenerate one,
		#	unless we don't get a Ruip either, in which case set it to the
		#	autogenerated Ruip. 
		# This means that the default behavior is that if neither Ruia nor Ruip
		#	are provided, we are assuming some entity is assigning a Ruip to 
		#	itself, and thus should be equal
		if ruia is None:
			if ruip is None:
				self.ruia = ruip
			else:
				self.ruia = Rui.Rui('A')
		else:
			self.ruia = ruia

		# If we don't get info about whether Ruip is singularly unique
		#	then we're going to assume it isn't
		if unique is None:
			self.unique = "-SU"
		else:
			self.unique = unique
		
		# If we don't get a timestamp for assignment of Ruip to some entity
		#	(assigned by Ruia), then assume Ruia is assigning Ruip at runtime
		if t is None:
			self.t = datetime.now(timezone.utc)
		else:
			self.t = t

# This class is the superclass of all Nto* tuples. They all relate some
#	non-repeatable portion of reality to some portion of reality (in 
#	some cases a repeatable PoR, and in others non-repeatable ones) or
#	in the case of NtoC, it is asserting that the N is "annotated by"
#	the "concept" from some concept system.
# We require the NtoXGenericTuple to accomodate NtoLackR
#	All the other Nto* tuples extend NtoXTuple
# 
class NtoXGenericTuple(RtTuple):
	def __init__(self, ruit, ruin, r):
		super().__init__(ruit)
		if ruin is None:
			raise Exception("must provide a value for RUIn")
		else:
			self.ruin = ruin
		if r is None:
			raise Exception("must provide a value for r")
		else:
			self.r = r 

# Except for NtoLackR, Nto* tuples can be asserted as being
#  true or false (i.e., "it is not the case that...")
class NtoXTuple(NtoXGenericTuple):
	def __init__(self, ruit, ruin, r, polarity):
		super().__init__(ruit, ruin, r)
		if (polarity):
			self.polarity = True
		else:
			self.polarity = False

	def isPositive(self):
		return self.polarity

	def isNegated(self):
		return not self.polarity


