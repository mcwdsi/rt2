import enum
from abc import ABC, abstractmethod
import logging

from rt_core_v2.ids_codes.Rui import Rui, TempRef
from rt_core_v2.metadata_accessory import TupleEventType, ValueEnum, RtChangeReason

"""Takes an set of enums and converts them into a dict with mapping entry:value"""
def enum_to_dict(entries: set):
	return {entry: entry.value for entry in entries}
	
"""Enum representing RUI statuses"""
class RuiStatus(ValueEnum):
	assigned = 'A'
	reserved = 'R'

"""Enum representing the tuple types"""
class TupleType(ValueEnum):
	A = 'A'
	D = 'D'
	F = 'F'
	NtoDE = 'NtoDE'
	NtoNTuple = 'NtoN'
	NtoRTuple = 'NtoRT'
	NtoC = 'NtoC'
	NtoLackR = 'NtoR(-)'

"""Enum representing portions of reality types"""
class PorType(ValueEnum):
	singular = '+SU'
	non_singular = '-SU'

#TODO Move this into the classes, as it is not a semantically sound placement here
class TupleComponents(enum.Enum):
	ruit = 'ruit'
	type = 'type'
	ar = 'ar'
	ruip = 'ruip'
	ruia = 'ruia'
	unique = 'unique'
	t = 't'
	ruid = 'ruid'
	event = 'event'
	event_reason = 'event_reason'
	td = 'td'
	replacements = 'replacements'
	ta = 'ta'
	C = 'C'
	polarity = 'polarity'
	r = 'r'
	p_list = 'p'
	rT = 'rT'
	tr = 'tr'
	inst = 'inst'
	ruin = 'ruin'
	ruir = 'ruir'
	ruics = 'ruics'
	code = 'code'
	data = 'data'
	ruidt = 'ruidt'

class RtTuple(ABC):
	"""Abstract Referent Tracking tuple that contains the information that all referent tracking tuples contain
	
	Attributes:
	ruit -- The rui of this tuple
	type -- The id of the tuple component
	"""
	tuple_type = None
	params = {**enum_to_dict({TupleComponents.ruit, TupleComponents.type})}
	def __init__(self, rui: Rui=None):
		self._rui = rui if rui else Rui()

	@property
	def ruit(self):
		"""Get the rui identifying this RtTuple"""
		return self._rui
	@ruit.setter
	def ruit(self, ruit):
		"""Set the rui identifying this RtTuple"""
		self._rui = ruit

	def __eq__(self, other):
		if not isinstance(other, type(self)):
			return False
		return self.__dict__ == other.__dict__

	@abstractmethod
	def get_str_attributes(self) -> dict:
		"""Get the attributes of this tuple as a string"""
		return {self.params[TupleComponents.ruit]:str(self._rui), self.params[TupleComponents.type]:str(self.tuple_type)}

class ATuple(RtTuple):
	"""Referent Tracking assignment tuple that registers assignment of an RUI to a PoR
	
	Attributes:
	ar -- The status of ruip
	ruip -- The Rui that is being assigned for the first time
	ruia -- The Rui of the author of this ATuple
	unique -- Asserts whether this is a non-repeatable or repeatable portion of reality
	t -- The time of the creation of the ATuple
	"""
	params = {**RtTuple.params, **enum_to_dict({TupleComponents.ar, TupleComponents.t, 
											 TupleComponents.ruia, TupleComponents.unique, TupleComponents.ruip})}
	tuple_type = TupleType.A

	def __init__(self, ruit: Rui=None, ruia: Rui=None, ruip: Rui=None, ar: RuiStatus=RuiStatus.assigned, unique: PorType=PorType.singular,
			  t: TempRef=None):
		super().__init__(ruit)
		self.ar = ar
		self.ruip = ruip if ruip else Rui()
		
		# If we don't get an author Rui for the tuple, then autogenerate one,
		#	unless we don't get a Ruip either, in which case set it to the
		#	autogenerated Ruip. 
		# This means that the default behavior is that if neither Ruia nor Ruip
		#	are provided, we are assuming some entity is assigning a Ruip to 
		#	itself, and thus should be equal
		self.ruia = ruia if ruia else Rui(self.ruip.uuid)
		self.unique = unique if type(unique) is PorType else PorType(unique)
		self._t = t if t else TempRef()
	@property
	def t(self):
		"""Get t"""
		return self._t
	@t.setter
	def t(self, t):
		"""Set t"""
		self._t = t

	def is_assigned(self):
		"""Returns whether this tuple is an assignment or not"""
		return self.ar is RuiStatus.assigned

	def is_reserved(self): 
		"""Returns whether this tuple is a reservation or not"""
		return self.ar is RuiStatus.reserved

	def get_str_attributes(self):
		"""Get the attributes of this tuple as a string"""
		attributes = super().get_str_attributes()
		attributes[self.params[TupleComponents.ruia]] = str(self.ruia)
		attributes[self.params[TupleComponents.ruip]] = str(self.ruip)
		attributes[self.params[TupleComponents.ar]] = str(self.ar)
		attributes[self.params[TupleComponents.unique]] = str(self.unique)
		attributes[self.params[TupleComponents.t]] = str(self._t)
		return attributes

	def create_assigned(self):
		"""Create an assignment A-tuple if this tuple is reserved"""
		if self.status is RuiStatus.assigned:
			logging.warning("status of Rui instance is already assigned. No change.")
			return self
		else:
			#TODO Figure out the process for creating d-tuples
			# return ATuple(self.ruip, self.ruia, self.ruit, self.unique, RuiStatus())
			pass

class DTuple(RtTuple):
	""" Referent Tracking metadata tuple that stores information regarding the instantation of other tuple types

	Attributes:
	ruit_ref -- The ruit of another tuple that this tuple stores information about
	event -- The category of reason that caused the creation of tuple ruit_ref
	event_reason -- The reason for the event above occuring
	td -- The time of this tuple's creation
	replacements -- Any tuples that will be replaced by ruit (if there are any)
	"""
	# D#< RUId, RUIT, t, ‘I’/E, R, S >

	tuple_type = TupleType.D
	params = {**RtTuple.params, **enum_to_dict({TupleComponents.ruid, TupleComponents.event, 
											 TupleComponents.event_reason, TupleComponents.t, 
											 TupleComponents.replacements})}

	def __init__(self, ruid: Rui, ruit: Rui, t: TempRef, event: TupleEventType, event_reason: RtChangeReason, replacements: list[Rui]=[]):
		super().__init__(ruid)
		self.ruit_ref = ruit
		self.event = event
		self.event_reason = event_reason
		self.td = t if t else TempRef()
		self.replacements = replacements.copy()

	def get_str_attributes(self):
		"""Get the attributes of this tuple as a string"""
		attributes = {}
		attributes[self.params[TupleComponents.type]] = self.tuple_type
		attributes[self.params[TupleComponents.ruid]] = self.ruid
		attributes[self.params[TupleComponents.ruit]] = self.ruit_ref
		attributes[self.params[TupleComponents.event]] = self.event.value
		attributes[self.params[TupleComponents.event_reason]] = self.event_reason.value
		attributes[self.params[TupleComponents.t]] = self.td
		attributes[self.params[TupleComponents.replacements]] = self.replacements
		return attributes
	
	@property
	def ruid(self):
		return self.ruit
	
	@ruid.setter
	def ruid(self, ruid):
		self.ruit = ruid

class FTuple(RtTuple):
	"""Referent Tracking metadata tuple that stores information regarding the confidence level in another tuple's assertions

	Attributes:
	ruid -- The ruid of this tuple
	ruia -- The ruid of the author making the assertion
	ruit_ref -- The ruid of the tuple refered to by this tuple's confidence assertion.
	ta -- The time instance of the confidence assertion.
	C -- The level of confidence from 0.00-1.00 in the assertion.
	"""
	#F#< RUId, ta, RUIa, RUIT, C >

	tuple_type = TupleType.F
	params = {**RtTuple.params, **enum_to_dict({TupleComponents.ruid, TupleComponents.ruia, TupleComponents.ta, TupleComponents.C})}
	
	def __init__(self, ruid: Rui=None, ruit: Rui=None, ta: TempRef=None, ruia: Rui=None, C: float=1.0):
		super().__init__(ruid)
		self.ruit_ref = ruit
		self.ruia = ruia
		self.ta = ta
		self.C = C

	def get_str_attributes(self):
		"""Get the attributes of this tuple as a string"""
		attributes = {}
		attributes[self.params[TupleComponents.type]] = str(self.tuple_type)
		attributes[self.params[TupleComponents.ruid]] = str(self.ruid)
		attributes[self.params[TupleComponents.ruit]] = str(self.ruit_ref)
		attributes[self.params[TupleComponents.ruia]] = str(self.ruia)
		attributes[self.params[TupleComponents.ta]] = str(self.ta)
		attributes[self.params[TupleComponents.C]] = self.C

		return attributes

	@property
	def ruid(self):
		return self.ruit
	
	@ruid.setter
	def ruid(self, ruid):
		self.ruit = ruid



class NtoNTuple(RtTuple):
	"""Tuple type that relates two or more non-repeatable portions of reality to one another
	
	Attributes:
	polarity -- Boolean describing whether the relation is as stated or negated
	relation -- A relation between the non-repeatable portions of reality in p_list
	p_list -- A list of non-repeatable portions of reality that have the relationship described
	time_relation -- The relationship between the time of the creation of this tuple and variable time
	time -- A temporal reference 
	"""
	#NtoNTuple#< ‘+’/‘-’, r, P, rT/‘-’, tr/‘-’ >
	tuple_type = TupleType.NtoNTuple
	params = {**RtTuple.params, **enum_to_dict({TupleComponents.polarity, TupleComponents.r, 
											 TupleComponents.p_list, TupleComponents.rT, TupleComponents.tr})}

	def __init__(self, ruit: Rui, polarity: bool, r: str, p: list[Rui], rT, tr: TempRef):
		super().__init__(ruit)
		self.polarity = polarity
		self.relation = r
		self.p_list = p.copy()
		self.time_relation = rT
		self.time = tr
	
	def get_str_attributes(self):
		"""Get the attributes of this tuple as a string"""
		attributes = super().get_str_attributes()
		attributes[self.params[TupleComponents.polarity]] = self.polarity
		attributes[self.params[TupleComponents.r]] = str(self.relation)
		attributes[self.params[TupleComponents.p_list]] = self.p_list
		attributes[self.params[TupleComponents.rT]] = str(self.time_relation)
		attributes[self.params[TupleComponents.tr]] = str(self.time)
		return attributes
	
class NtoRTuple(RtTuple):
	"""Tuple type that relates a non-repeatable portion of reality to a repeatable portion of reality
	
	Attribtues:
	polarity -- Boolean describing whether the relation is as stated or negated
	inst -- The instantiation relationship between the non-repeatable PoR an the repeatable PoR
	ruin -- The Rui of the non-repeatable PoR in the relation
	ruir -- The Rui of the repeatable Por in the relation
	time_relation -- The relationship between the time of the creation of this tuple and variable time
	time -- A temporal reference 
	"""
	#NtoRTuple#< ‘+’/‘-’, inst, RUIn, RUIr, rT/‘-’, tr/‘-’ >

	tuple_type = TupleType.NtoRTuple
	params = {**RtTuple.params, **enum_to_dict({TupleComponents.polarity, TupleComponents.inst, TupleComponents.ruin, 
											   TupleComponents.ruir, TupleComponents.rT, TupleComponents.tr})}

	def __init__(self, ruit: Rui, polarity: bool, inst: str, ruin: Rui, ruir: Rui, rT, tr: TempRef):
		super().__init__(ruit)
		self.polarity = polarity
		self.inst = inst
		self.ruin = ruin
		self.ruir = ruir
		self.time_relation = rT
		self.time = tr 

	def get_str_attributes(self):
		"""Get the attributes of this tuple as a string"""
		attributes = super().get_str_attributes()
		attributes[self.params[TupleComponents.polarity]] = self.polarity
		attributes[self.params[TupleComponents.inst]] = str(self.inst)
		attributes[self.params[TupleComponents.ruin]] = str(self.ruin)
		attributes[self.params[TupleComponents.ruir]] = str(self.ruir)
		attributes[self.params[TupleComponents.rT]] = str(self.time_relation)
		attributes[self.params[TupleComponents.tr]] = str(self.time)
		return attributes

#TODO Use concepts
class NtoCTuple(RtTuple):
	"""Tuple type that annotates a non-repeatable portion of reality with a "concept" code from a
		concept-based system
		
		Attributes:
		polarity -- Boolean describing whether the relation is as stated or negated
		relation -- The relationship between the non-repeatable PoR and the concept
		ruics -- The Rui of the concept class the concept for the relation is from
		ruip -- The Rui of the non-repeatable PoR in the relation
		code -- The code for the concept within the concept class referred to by Ruics
		time_relation -- The relationship between the time of the creation of this tuple and variable time
		time -- A temporal reference
		"""
	#NtoC#< ‘+’/‘-’, r, RUIcs, RUIp, code, rT, tr >

	tuple_type = TupleType.NtoC
	params = {**RtTuple.params, **enum_to_dict({TupleComponents.polarity, TupleComponents.r, TupleComponents.ruics, 
											   TupleComponents.ruip, TupleComponents.code, TupleComponents.rT, TupleComponents.tr})}
	
	def __init__(self, ruit: Rui, polarity: bool, r: str, ruics: Rui, ruip: Rui, code: str, rT, tr: TempRef):
		super().__init__(ruit)
		self.polarity = polarity
		self.reason = r
		self.ruics = ruics
		self.ruip = ruip
		self.code = code
		self.time_relation = rT
		self.time = tr

	def get_str_attributes(self):
		"""Get the attributes of this tuple as a string"""
		attributes = super().get_str_attributes()
		attributes[self.params[TupleComponents.polarity]] = self.polarity
		attributes[self.params[TupleComponents.r]] = str(self.reason)
		attributes[self.params[TupleComponents.ruics]] = str(self.ruics)
		attributes[self.params[TupleComponents.ruip]] = str(self.ruip)
		attributes[self.params[TupleComponents.code]] = str(self.code)
		attributes[self.params[TupleComponents.rT]] = str(self.time_relation)
		attributes[self.params[TupleComponents.tr]] = str(self.time)
		return attributes

# We use NtoDE instead of NtoI, and we use an instance for the identifying descriptor
# or IdD associated with:
#	(1) and NtoRTuple tuple that says what type of IdD it is, 
#	(2) an NtoNTuple tuple to relate the name to what the IdD denotes, and 
#	(3) an NtoDE tuple to hold the actual written (or "string") form of the IdD. 
# Note that an IdD can be a name, identifier, etc.
#TODO Figure out if data should be a string or generic data
class NtoDETuple(RtTuple):
	"""Tuple type that creates a connection between a non-repeatable portion of reality and a piece of data
	
	Attributes:
	polarity -- Boolean describing whether the relation is as stated or negated
	ruin -- The Rui of the tuple that the data is atrributed to
	data -- The data in the relationship
	ruidt -- An Rui containing the data type of data
	"""
	#NtoDE#< '+/-', r, ruin, data, ruidt>

	tuple_type = TupleType.NtoDE
	params = {**RtTuple.params, **enum_to_dict({TupleComponents.polarity, TupleComponents.ruin, 
											   TupleComponents.data, TupleComponents.ruidt})}

	def __init__(self, ruit: Rui, polarity: bool, ruin: Rui, data, ruidt: Rui):
		super().__init__(ruit)
		self.polarity = polarity
		self.ruin = ruin
		self.data = data
		self.ruidt = ruidt

	def get_str_attributes(self):
		"""Get the attributes of this tuple as a string"""
		attributes = super().get_str_attributes()
		attributes[self.params[TupleComponents.polarity]] = self.polarity
		attributes[self.params[TupleComponents.ruin]] = str(self.ruin)
		attributes[self.params[TupleComponents.data]] = str(self.data)
		attributes[self.params[TupleComponents.ruidt]] = str(self.ruidt)
		return attributes

class NtoLackRTuple(RtTuple):
	"""Tuple type that relates a non-repeatable portion of reality to a repeatable portion of reality in a negative relationship
	
	Attribtues:
	relation -- A relationship between a non-repeatable portion of reality and a repeatable portion of reality
	ruip -- The rui of the repeatable portion of reality that the non-repeatable does not have the relation to
	ruir -- The rui of the non-repeatable portion fo reality that does not have relation to the POR refered to buy ruip
	time_relation -- The relationship between the time of the creation of this tuple and variable time
	time -- A temporal reference 
	"""
	#NtoRTuple(-) -tuple NtoRTuple(-)#< r, RUIp, RUIr, rT/‘-’, tr/‘-’ >

	tuple_type = TupleType.NtoLackR
	params = {**RtTuple.params, **enum_to_dict({TupleComponents.r, TupleComponents.ruip, 
													  TupleComponents.ruir, TupleComponents.rT, TupleComponents.tr})}
	

	def __init__(self, ruit: Rui, r: str, ruip: Rui, ruir: Rui, rT, tr: TempRef):
		super().__init__(ruit)
		self.relation = r
		self.ruip = ruip
		self.ruir = ruir
		self.time_relation = rT
		self.time = tr 

	def get_str_attributes(self):
		"""Get the attributes of this tuple as a string"""
		attributes = super().get_str_attributes()
		attributes[self.params[TupleComponents.r]] = str(self.relation)
		attributes[self.params[TupleComponents.ruip]] = str(self.ruip)
		attributes[self.params[TupleComponents.ruir]] = str(self.ruir)
		attributes[self.params[TupleComponents.rT]] = str(self.time_relation)
		attributes[self.params[TupleComponents.tr]] = str(self.time)
		return attributes
	
"""Mapping from tuple id to the corresponding tuple class"""
type_to_class = {
	TupleType.A: ATuple,
	TupleType.D: DTuple,
	TupleType.F: FTuple,
	TupleType.NtoDE: NtoDETuple,
	TupleType.NtoNTuple: NtoNTuple,
	TupleType.NtoRTuple: NtoRTuple,
	TupleType.NtoC: NtoCTuple,
	TupleType.NtoLackR: NtoLackRTuple,
}
