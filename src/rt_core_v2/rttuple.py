from datetime import datetime, timezone
import enum

from ids_codes.Rui import Rui, TempRef
from abc import ABC, abstractmethod

"""Enum for when the string representation of an enum instance is the value"""
class ValueEnum(enum.Enum):
	def __str__(self):
		return str(self.value)
"""Enum representing RUI statuses"""
class RuiStatus(ValueEnum):
	assigned = 'A'
	reserved = 'R'

class MetaTupleType(ValueEnum):
	insertion = 'I'
	error = 'E'

"""Enum representing the tuple types"""
class TupleType(ValueEnum):
	A = 'A'
	D = 'D'
	F = 'F'
	NtoDE = 'NtoDE'
	NtoN = 'NtoN'
	NtoR = 'NtoR'
	NtoC = 'NtoC'
	NtoLackR = 'NtoR(-)'

#TODO Should polarity be a boolean or an enum? Seems reasonable, but this represents the string output
class TuplePolarity(ValueEnum):
	positive = '+'
	negative = '-'

"""Enum representing portions of reality types"""
class PorType(ValueEnum):
	singular = '+SU'
	non_singular = '-SU'

class IterableEnum(enum.Enum):
	def member_set(cls):
		return set(map(lambda c: c.value, cls))

class TupleComponents(IterableEnum):
	ruit = 'ruit'
	type = 'type'
	ruin = 'ruin'
	r = 'r'
	polarity = 'polarity'
	ruip = 'ruip'
	ruia = 'ruia'
	unique = 'unique'
	ar = 'ar'
	t = 't'
	p_list = 'p_list'
	tr = 'tr'
	ruir = 'ruir'
	ruics = 'ruics'
	code = 'code'
	ruins = 'ruins'
	data = 'data'
	ruidt = 'ruidt'
	event = 'event'
	event_reason = 'event_reason'
	error = 'error'
	td = 'td'
	replacements = 'replacements'
	ta = 'ta'
	C = 'C'
	ruitn = 'ruitn'

class RtTupleMembers(IterableEnum):
	ruit = 'ruit'
	type = 'type'
	
class NtoXGenericTupleMembers(IterableEnum):
	ruit = 'ruit'
	type = 'type'
	ruin = 'ruin'
	r = 'r'

class NtoXTupleMembers(IterableEnum):
	ruit = 'ruit'
	type = 'type'
	ruin = 'ruin'
	r = 'r'
	polarity = 'polarity'


class ATupleMembers(IterableEnum):
	ruit = 'ruit'
	type = 'type'
	ruip = 'ruip'
	ruia = 'ruia'
	unique = 'unique'
	ar = 'ar'
	t = 't'
	
	
class NtoNMembers(IterableEnum):
	ruit = 'ruit'
	type = 'type'
	ruin = 'ruin'
	r = 'r'
	polarity = 'polarity'
	p_list = 'p_list'
	tr = 'tr'

class NtoRMembers(IterableEnum):
	ruit = 'ruit'
	type = 'type'
	ruin = 'ruin'
	r = 'r'
	polarity = 'polarity'
	ruir = 'ruir'
	tr = 'tr'
	
class NtoCMembers(IterableEnum):
	ruit = 'ruit'
	type = 'type'
	ruin = 'ruin'
	r = 'r'
	polarity = 'polarity'
	ruics = 'ruics'
	code = 'code'
	
class NtoDEMembers(IterableEnum):
	ruit = 'ruit'
	type = 'type'
	ruin = 'ruin'
	r = 'r'
	polarity = 'polarity'
	ruins = 'ruins'
	data = 'data'
	ruidt = 'ruidt'

class NtoLackRMembers(IterableEnum):
	ruit = 'ruit'
	type = 'type'
	ruin = 'ruin'
	r = 'r'
	ruir = 'ruir'
	tr = 'tr'

class DTupleMembers(IterableEnum):
	ruit = 'ruit'
	type = 'type'
	ruid = 'ruid'
	event = 'event'
	event_reason = 'event_reason'
	error = 'error'
	td = 'td'
	replacements = 'replacements'

class FTupleMembers(IterableEnum):
	ruit = 'ruit'
	type = 'type'
	ruia = 'ruia'
	ta = 'ta'
	C = 'C'
	ruitn = 'ruitn'

tuple_to_params = {
	TupleType.A: ATupleMembers,
	TupleType.D: DTupleMembers,
	TupleType.F: FTupleMembers,
	TupleType.NtoDE:NtoDEMembers,
	TupleType.NtoN: NtoNMembers,
	TupleType.NtoR:NtoRMembers,
	TupleType.NtoC: NtoCMembers,
	TupleType.NtoLackR: NtoLackRMembers
}

class RtTuple(ABC):
	tuple_type = None
	def __init__(self, rui: Rui=None):
		self._rui = rui if rui else Rui()

	@property
	def ruit(self):
		"""Get the rui identifying this RtTuple"""
		return self._rui
	@ruit.setter
	def ruit(self, ruit):
		"""Set the rui identifying this RtTuple"""
		self._rui = ruit


	@abstractmethod
	def get_str_attributes(self):
		"""Get the attributes of this tuple as a string"""
		return {ATupleMembers.ruit.value:str(self._rui), ATupleMembers.type.value:str(self.tuple_type)}

class Atuple(RtTuple):
	"""Referent Tracking assignment tuple that registers assignment of an RUI to a PoR
	
	Attributes:
	ar -- The status of ruip
	ruip -- The Rui that is being assigned for the first time
	ruia -- The Rui of the author of this Atuple
	unique -- 
	t -- The time of the creation of the Atuple
	"""

	tuple_type = TupleType.A
	params = ATupleMembers

	def __init__(self, ruip: Rui=None, ruia: Rui=None, ruit: Rui=None, unique: PorType=PorType.singular, ar: RuiStatus=RuiStatus.assigned, 
			  t=datetime.now(timezone.utc)):
		super().__init__(ruit)
		self.ar = ar
		self.ruip = ruip if ruip else Rui()
		
		# If we don't get an author Rui for the tuple, then autogenerate one,
		#	unless we don't get a Ruip either, in which case set it to the
		#	autogenerated Ruip. 
		# This means that the default behavior is that if neither Ruia nor Ruip
		#	are provided, we are assuming some entity is assigning a Ruip to 
		#	itself, and thus should be equal
		self.ruia = ruia if ruia else Rui(self.ruip.uuid)
		self.unique = unique if type(unique) is PorType else PorType(unique)
		self._t = TempRef(t)

	@property
	def t(self):
		"""Get t"""
		return self._t
	@t.setter
	def t(self, t):
		"""Set t"""
		self._t = t

	def is_assigned(self):
		"""Returns whether this tuple is an assignment or not"""
		return self.ar is RuiStatus.assigned

	def is_reserved(self): 
		"""Returns whether this tuple is a reservation or not"""
		return self.ar is RuiStatus.reserved

	def get_str_attributes(self):
		"""Get the attributes of this tuple as a string"""
		attributes = super().get_str_attributes()
		attributes[self.params.ar.value] = str(self.ar)
		attributes[self.params.t.value] = str(self._t)
		attributes[self.params.ruia.value] = str(self.ruia)
		attributes[self.params.unique.value] = str(self.unique)
		attributes[self.params.ruip.value] = str(self.ruip)
		return attributes

	def create_assigned(self):
		"""Create an assignment A-tuple if this tuple is reserved"""
		if self.status is RuiStatus.assigned:
			logging.warning("status of Rui instance is already assigned. No change.")
			return self
		else:
			#TODO Figure out the process for creating d-tuples
			return Atuple(self.ruip, self.ruia, self.ruit, self.unique, RuiStatus())

	


# This class is the superclass of all Nto* tuples. They all relate some
#	non-repeatable portion of reality to some portion of reality (in 
#	some cases a repeatable PoR, and in others non-repeatable ones) or
#	in the case of NtoC, it is asserting that the N is "annotated by"
#	the "concept" from some concept system.
# We require the NtoXGenericTuple to accomodate NtoLackR
#	All the other Nto* tuples extend NtoXTuple
#
class NtoXGenericTuple(RtTuple):

	params = NtoNMembers

	def __init__(self, ruit: Rui, ruin: Rui, r: str):
		super().__init__(ruit)
		if ruin is None:
			raise Exception("must provide a value for RUIn")
		if r is None:
			raise Exception("must provide a value for r")
		
		self.ruin = ruin
		self.r = r 

	def get_str_attributes(self):
		"""Get the attributes of this tuple as a string"""
		attributes = super().get_str_attributes()
		attributes[self.params.ruin.value] = str(self.ruin)
		attributes[self.params.r.value] = str(self.r)
		return attributes

# Except for NtoLackR, Nto* tuples can be asserted as being
#  true or false (i.e., "it is not the case that...")
class NtoXTuple(NtoXGenericTuple):

	params = NtoNMembers

	def __init__(self, ruit: Rui, ruin: Rui, r: str, polarity: bool):
		super().__init__(ruit, ruin, r)
		self.polarity = polarity

	def isPositive(self):
		"""Returns whehther the polarity is positive"""
		return self.polarity

	def isNegated(self):
		"""Returns whether the polarity is negative"""
		return not self.polarity
	
	def get_str_attributes(self):
		"""Get the attributes of this tuple as a string"""
		attributes = super().get_str_attributes()
		attributes[self.params.polarity.value] = str(self.polarity)
		return attributes

class NtoN(NtoXTuple):
	"""Tuple type that relates two or more non-repeatable portions of reality to one another"""
	#NtoN#< ‘+’/‘-’, r, P, rT/‘-’, tr/‘-’ >

	tuple_type = TupleType.NtoN
	params = NtoNMembers

	def __init__(self, ruit: Rui, ruin: Rui, polarity: bool, r: str, p_list: list[Rui], tr: str):
		super().__init__(ruit, ruin, r, polarity)
		self.p_list = p_list.copy()
		self.tr = tr
	
	def get_str_attributes(self):
		"""Get the attributes of this tuple as a string"""
		attributes = super().get_str_attributes()
		attributes[self.params.p_list.value] = str(self.p_list)
		attributes[self.params.tr.value] = str(self.tr)
		return attributes
	
class NtoR(NtoXTuple):
	"""Tuple type that relates a non-repeatable portion of reality to a repeatable portion of reality"""
	#NtoR#< ‘+’/‘-’, inst, RUIn, RUIr, rT/‘-’, tr/‘-’ >

	tuple_type = TupleType.NtoR
	params = NtoRMembers

	def __init__(self, ruit: Rui, ruin: Rui, polarity: bool, r: str, ruir: Rui, tr: str):
		super().__init__(ruit, ruin, r, polarity)
		self.tr = tr 
		self.ruir = ruir

	def get_str_attributes(self):
		"""Get the attributes of this tuple as a string"""
		attributes = super().get_str_attributes()
		attributes[self.params.ruir.value] = str(self.ruir)
		attributes[self.params.tr.value] = str(self.tr)
		return attributes

#TODO Figure out the type of code
class NtoC(NtoXTuple):
	"""Tuple type that annotates a non-repeatable portion of reality with a "concept" code from a
		concept-based system"""
	#NtoC#< ‘+’/‘-’, r, RUIcs, RUIp, code, rT, tr >

	tuple_type = TupleType.NtoC
	params = NtoCMembers
	
	def __init__(self, ruit: Rui, ruin: Rui, polarity: bool, r: str, ruics: Rui, code, tr: str):
		super().__init__(ruit, ruin, r, polarity)
		self.tr = tr 
		self.ruics = ruics
		self.code = code 

	def get_str_attributes(self):
		"""Get the attributes of this tuple as a string"""
		attributes = super().get_str_attributes()
		attributes[self.params.ruics.value] = str(self.ruics)
		attributes[self.params.code.value] = str(self.code)
		return attributes

# We use NtoDE instead of NtoI, and we use an instance for the identifying descriptor
# or IdD associated with:
#	(1) and NtoR tuple that says what type of IdD it is, 
#	(2) an NtoN tuple to relate the name to what the IdD denotes, and 
#	(3) an NtoDE tuple to hold the actual written (or "string") form of the IdD. 
# Note that an IdD can be a name, identifier, etc.
#TODO Figure out if data should be a string or generic data
class NtoDE(NtoXTuple):
	#NtoDE#< '+/-', r, ruin, ruins, data, ruidt >

	tuple_type = TupleType.NtoDE
	params = NtoDEMembers
	def __init__(self, ruit: Rui, ruin: Rui, polarity: bool, r: str, ruins: Rui, data, ruidt: Rui):
		super().__init__(ruit, ruin, r, polarity)
		self.ruins = ruins
		self.data = data
		self.ruidt = ruidt
	
	def get_str_attributes(self):
		"""Get the attributes of this tuple as a string"""
		attributes = super().get_str_attributes()
		attributes[self.params.ruins.value] = str(self.ruins)
		attributes[self.params.data.value] = str(self.data)
		attributes[self.params.ruidt.value] = str(self.ruidt)
		return attributes

class NtoLackR(NtoXGenericTuple):
	"""Tuple type that asserts that for all instances of a given type, a specific
		non-repeatable portion of reality is not related to any of them by a 
		given relation"""
	#NtoR(-) -tuple NtoR(-)#< r, RUIp, RUIr, rT/‘-’, tr/‘-’ >

	tuple_type = TupleType.NtoLackR
	params = NtoLackRMembers

	def __init__(self, ruit: Rui, ruin: Rui, r: str, ruir: Rui, tr: str):
		super()._init__(self, ruit, ruin, r)
		self.ruir = ruir
		self.tr = tr 

	def get_str_attributes(self):
		"""Get the attributes of this tuple as a string"""
		attributes = super().get_str_attributes()
		attributes[self.params.ruir.value] = str(self.ruir)
		attributes[self.params.tr.value] = str(self.tr)
		return attributes

class Dtuple(RtTuple):
	# D#< RUId, RUIT, t, ‘I’/E, R, S >

	tuple_type = TupleType.D
	params = DTupleMembers

	def __init__(self, ruit: Rui, ruid: Rui, event, event_reason, error, td=None, replacements=None):
		super().__init__(ruid)
		self.ruit_ref = ruit
		self.event = event
		self.event_reason = event_reason
		self.error = error
		self.td = td if td else datetime.now(timezone.utc)
		self.replacements = replacements.copy() if replacements else None

	def get_str_attributes(self):
		"""Get the attributes of this tuple as a string"""
		attributes = {}
		attributes[self.params.ruid.value] = str(self.ruid)
		attributes[self.params.ruit.value] = str(self.ruit_ref)
		attributes[self.params.event.value] = str(self.event)
		attributes[self.params.event_reason.value] = str(self.event_reason)
		attributes[self.params.error.value] = str(self.error)
		attributes[self.params.td.value] = str(self.td)
		attributes[self.params.replacements.value] = str(self.td)
		return attributes

class Ftuple(RtTuple):
	#F#< RUId, ta, RUIa, RUIT, C >

	tuple_type = TupleType.F
	params = FTupleMembers
	
	def __init__(self, ruitn: Rui, ruia: Rui, ta: TempRef, C: float, ruit: Rui=None):
		super().__init__(ruit)
		# ruitn denotes the tuple that this Ftuple is about
		self.ruitn = ruitn
		self.ruia = ruia
		#TODO - we need to figure out how to do time parameters
		self.ta = ta
		self.C = C

	def get_str_attributes(self):
		"""Get the attributes of this tuple as a string"""
		attributes = super().get_str_attributes()
		attributes[self.params.ruitn.value] = str(self.ruitn)
		attributes[self.params.ruia.value] = str(self.ruia)
		attributes[self.params.ta.value] = str(self.ta)
		attributes[self.params.C.value] = str(self.C)

		return attributes