from datetime import datetime, timezone

from src.ids_codes.Rui import Rui, RuiStatus

class RtTuple:
	def __init__(self, ruit=None):
		self.ruit = ruit if ruit else Rui(RuiStatus.assigned)

	def get_ruit(self):
		return self.ruit 


class Atuple(RtTuple):
	"""Referent Tracking assignment tuple that registers assignment of an RUI to a PoR
	
	Attributes:
	ar -- The status of ruip
	ruip -- The Rui that is being assigned for the first time
	ruia -- The Rui of the author of this Atuple
	unique -- 
	t -- The time of the creation of the Atuple
	"""

	def __init__(self, ruip=None, ruia=None, ruit=None, unique="-SU", ar=RuiStatus.assigned, t=datetime.now(timezone.utc)):
		super().__init__(ruit)

		# If we don't get a value for whether the Rui is assigned or reserved
		#	then we assume that it is assigned
		self.ar = ar

		# If we don't get a Ruip, then we'll create one on the fly
		self.ruip = ruip if ruip else Rui(self.ar)
		
		# If we don't get an author Rui for the tuple, then autogenerate one,
		#	unless we don't get a Ruip either, in which case set it to the
		#	autogenerated Ruip. 
		# This means that the default behavior is that if neither Ruia nor Ruip
		#	are provided, we are assuming some entity is assigning a Ruip to 
		#	itself, and thus should be equal
		self.ruia = ruia
		if self.ruia is None:
			print(self.ruip.uuid)
			self.ruia = Rui(self.ruip.status, self.ruip.uuid)

		self.unique = unique
		self.t = t

	def getTimestamp(self):
		return self.t

# This class is the superclass of all Nto* tuples. They all relate some
#	non-repeatable portion of reality to some portion of reality (in 
#	some cases a repeatable PoR, and in others non-repeatable ones) or
#	in the case of NtoC, it is asserting that the N is "annotated by"
#	the "concept" from some concept system.
# We require the NtoXGenericTuple to accomodate NtoLackR
#	All the other Nto* tuples extend NtoXTuple
# 
class NtoXGenericTuple(RtTuple):
	def __init__(self, ruit, ruin, r):
		super().__init__(ruit)
		if ruin is None:
			raise Exception("must provide a value for RUIn")
		if r is None:
			raise Exception("must provide a value for r")
		
		self.ruin = ruin
		self.r = r 

# Except for NtoLackR, Nto* tuples can be asserted as being
#  true or false (i.e., "it is not the case that...")
class NtoXTuple(NtoXGenericTuple):
	def __init__(self, ruit, ruin, r, polarity: bool):
		super().__init__(ruit, ruin, r)
		self.polarity = polarity

	def isPositive(self):
		return self.polarity

	def isNegated(self):
		return not self.polarity


class NtoN(NtoXTuple):

	"""Tuple type that relates two or more non-repeatable portions of reality to one another"""

	#NtoN#< ‘+’/‘-’, r, P, rT/‘-’, tr/‘-’ >
	def __init__(self, ruit, ruin, polarity, r, p_list, tr):
		super().__init__(ruit, ruin, r, polarity)
		self.p_list = p_list.copy()
		self.tr = tr

class NtoR(NtoXTuple):

	"""Tuple type that relates a non-repeatable portion of reality to a repeatable portion of reality"""

	#NtoR#< ‘+’/‘-’, inst, RUIn, RUIr, rT/‘-’, tr/‘-’ >
	def __init__(self, ruit, ruin, polarity, r, ruir, tr):
		super().__init__(ruit, ruin, r, polarity)
		self.tr = tr 
		self.ruir = ruir

class NtoC(NtoXTuple):

	"""Tuple type that annotates a non-repeatable portion of reality with a "concept" code from a
		concept-based system"""

	#NtoC#< ‘+’/‘-’, r, RUIcs, RUIp, code, rT, tr >
	def __init__(self, ruit, ruin, polarity, r, ruics, code, tr):
		super().__init__(ruit, ruin, r, polarity)
		self.tr = tr 
		self.ruics = ruics
		self.code = code 

# We use NtoDE instead of NtoI, and we use an instance for the identifying descriptor
# or IdD associated with:
#	(1) and NtoR tuple that says what type of IdD it is, 
#	(2) an NtoN tuple to relate the name to what the IdD denotes, and 
#	(3) an NtoDE tuple to hold the actual written (or "string") form of the IdD. 
# Note that an IdD can be a name, identifier, etc.
class NtoDE(NtoXTuple):
	#NtoDE#< '+/-', r, ruin, ruins, data, ruidt >
	def __init__(self, ruit, ruin, polarity, r, ruins, data, ruidt):
		super().__init__(ruit, ruin, r, polarity)
		self.ruins = ruins
		self.data = data
		self.ruidt = ruidt

class NtoLackR(NtoXGenericTuple):

	"""Tuple type that asserts that for all instances of a given type, a specific
		non-repeatable portion of reality is not related to any of them by a 
		given relation"""

	#NtoR(-) -tuple NtoR(-)#< r, RUIp, RUIr, rT/‘-’, tr/‘-’ >
	def __init__(self, ruit, ruin, r, ruir, tr):
		super()._init__(self, ruit, ruin, r)
		self.ruir = ruir
		self.tr = tr 

class Dtuple(RtTuple):
	# D#< RUId, RUIT, t, ‘I’/E, R, S >
	def __init__(self, ruit, ruid, event, event_reason, error, td=None, replacements=None):
		super().__init__(ruit)
		self.ruid = ruid
		self.event = event
		self.event_reason = event_reason
		self.error = error
		if td is None:
			self.td = datetime.now(timezone.utc)
		else:
			self.td = td
		if replacements is None:
			self.replacements = replacements
		else:
			self.replacements = replacements.copy()

class Ftuple(RtTuple):
	#F#< RUId, ta, RUIa, RUIT, C >
	def __init__(self, ruitn, ruia, ta, C, ruit=None):
		super().__init__(ruit)
		# ruitn denotes the tuple that this Ftuple is about
		self.ruitn = ruitn
		self.ruia = ruia
		#TO DO - we need to figure out how to do time parameters
		self.ta = ta
		self.C = C